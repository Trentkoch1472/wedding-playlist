// src/useSpotify.js
import { useCallback, useEffect, useState } from "react";

const AUTH_URL = "https://accounts.spotify.com/authorize";
const API_BASE = "https://api.spotify.com/v1";

export default function useSpotify({
  clientId,
  redirectUri,
  scopes = ["playlist-modify-public", "playlist-modify-private"],
}) {
  const [token, setToken] = useState(null);
  const [user, setUser] = useState(null);
  const [busy, setBusy] = useState(false);
  const [msg, setMsg] = useState("");

  // Parse token from hash (Implicit Grant)
  useEffect(() => {
    const hash = window.location.hash.startsWith("#")
      ? window.location.hash.slice(1)
      : "";
    const params = new URLSearchParams(hash);
    const accessToken = params.get("access_token");
    const expiresIn = params.get("expires_in");

    if (accessToken) {
      window.history.replaceState({}, document.title, window.location.pathname + window.location.search);
      setToken(accessToken);
      try {
        const expAt = Date.now() + (parseInt(expiresIn || "3600", 10) * 1000);
        localStorage.setItem("sp_token", JSON.stringify({ accessToken, expAt }));
      } catch {}
      return;
    }

    // Restore from storage
    try {
      const raw = localStorage.getItem("sp_token");
      if (raw) {
        const saved = JSON.parse(raw);
        if (saved?.accessToken && saved?.expAt > Date.now()) {
          setToken(saved.accessToken);
        } else {
          localStorage.removeItem("sp_token");
        }
      }
    } catch {}
  }, []);

  // Load profile
  useEffect(() => {
    if (!token) return;
    (async () => {
      try {
        const r = await fetch(`${API_BASE}/me`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        if (!r.ok) throw new Error(`Profile ${r.status}`);
        setUser(await r.json());
      } catch (e) {
        console.error(e);
        setMsg("Spotify auth expired. Please sign in again.");
        setToken(null);
        localStorage.removeItem("sp_token");
      }
    })();
  }, [token]);

  const login = useCallback(() => {
    const url = new URL(AUTH_URL);
    url.searchParams.set("client_id", clientId);
    url.searchParams.set("response_type", "token");
    url.searchParams.set("redirect_uri", redirectUri);
    url.searchParams.set("scope", scopes.join(" "));
    url.searchParams.set("show_dialog", "true");
    console.log("Spotify AUTH URL:", url.toString());
    window.location.assign(url.toString());
  }, [clientId, redirectUri, scopes]);

  // ðŸ”Ž NEW: find art/preview via Spotify as a fallback (requires user to be logged in)
  const findTrackMeta = useCallback(
    async (title, artist) => {
      if (!token) return null;
      const q = [title, artist].filter(Boolean).join(" ");
      try {
        const r = await fetch(
          `${API_BASE}/search?type=track&limit=1&q=${encodeURIComponent(q)}`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        if (!r.ok) return null;
        const js = await r.json();
        const t = js.tracks?.items?.[0];
        if (!t) return null;
        const preview = t.preview_url || null;              // https
        const art = t.album?.images?.[0]?.url || null;      // https
        return { preview, art };
      } catch {
        return null;
      }
    },
    [token]
  );

  const exportToSpotify = useCallback(
    async (stars, yeses) => {
      if (!token || !user) { setMsg("Sign in to Spotify first."); return null; }
      setBusy(true); setMsg("Creating playlistâ€¦");
      try {
        const name = "Swipe to Dance";
        const createRes = await fetch(`${API_BASE}/users/${user.id}/playlists`, {
          method: "POST",
          headers: { Authorization: `Bearer ${token}`, "Content-Type": "application/json" },
          body: JSON.stringify({ name, description: "Generated by Swipe to Dance", public: false })
        });
        if (!createRes.ok) throw new Error(`Create playlist ${createRes.status}`);
        const playlist = await createRes.json();

        const wanted = [...stars, ...yeses];
        const uris = [];
        for (const s of wanted) {
          const q = [s.title, s.artist].filter(Boolean).join(" ");
          const sr = await fetch(`${API_BASE}/search?type=track&limit=1&q=${encodeURIComponent(q)}`, {
            headers: { Authorization: `Bearer ${token}` }
          });
          if (!sr.ok) continue;
          const js = await sr.json();
          const t = js.tracks?.items?.[0];
          if (t?.uri) uris.push(t.uri);
        }

        for (let i = 0; i < uris.length; i += 100) {
          const chunk = uris.slice(i, i + 100);
          await fetch(`${API_BASE}/playlists/${playlist.id}/tracks`, {
            method: "POST",
            headers: { Authorization: `Bearer ${token}`, "Content-Type": "application/json" },
            body: JSON.stringify({ uris: chunk })
          });
        }

        setMsg("Playlist ready!");
        return playlist.external_urls?.spotify || null;
      } catch (e) {
        console.error(e);
        setMsg("Spotify export failed.");
        return null;
      } finally {
        setBusy(false);
      }
    },
    [token, user]
  );

  return { user, busy, msg, login, exportToSpotify, findTrackMeta };
}
